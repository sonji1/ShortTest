cscope 16 C:\sonji\Bioptro\ACE400_ShortTest\ACE400_ShortTest"               0000044350
	@ACE400MainDlg.h

4 #i!
defed
(
AFX_ACE400_ShtTeDLG_H__A60D6315_99C4_46C0_A323_42C7B357B0A2__INCLUDED_
)

5 
	#AFX_ACE400_ShtTeDLG_H__A60D6315_99C4_46C0_A323_42C7B357B0A2__INCLUDED_


	)

7 
	~"ShtTeDlog.h
"

8 
	~"CfigDlog.h
"

10 #i
_MSC_VER
 > 1000

11 #agm



17 as
	cCACE400MaDlg
 : 
public
 
CDlog


20 
public
:

21 
CShtTeDlog
 
m_ShtTeDlg
;

22 
CCfigDlog
 
	mm_CfigDlg
;

24 
CACE400MaDlg
(
CWnd
* 
pPt
 = 
NULL
);

28 um { 
	mIDD
 = 
IDD_MAIN_DIALOG
 };

34 
	gpublic
:

35 
vtu
 
BOOL
 
PTneMesge
(
MSG
* 
pMsg
);

36 
	geed
:

37 
vtu
 
DoDaExchge
(
CDaExchge
* 
pDX
);

41 
	geed
:

42 
HICON
 
m_hIc
;

46 
vtu
 
BOOL
 
OnInDlog
();

47 
afx_msg
 
OnSysCommd
(
UINT
 
nID
, 
LPARAM
 
lPam
);

48 
afx_msg
 
OnPat
();

49 
afx_msg
 
HCURSOR
 
OnQuyDgIc
();

50 
afx_msg
 
OnBuShtTe
();

51 
afx_msg
 
OnBuCfig
();

53 
DECLARE_MESSAGE_MAP
()

	@ACE400_ShortTest.h

4 #i!
defed
(
AFX_ACE400_ShtTe_H__CB3F7139_0C6D_46B6_A240_563945A8EA0D__INCLUDED_
)

5 
	#AFX_ACE400_ShtTe_H__CB3F7139_0C6D_46B6_A240_563945A8EA0D__INCLUDED_


	)

7 #i
_MSC_VER
 > 1000

8 #agm



11 #ide
__AFXWIN_H__


12 #r 
ude
 'dafx.h' 
befe
 
udg
 
this
 
fe
 
PCH


15 
	~"sour.h
"

22 as
	cCACE400_ShtTeA
 : 
public
 
CWA


24 
public
:

25 
CACE400_ShtTeA
();

30 
	mpublic
:

31 
vtu
 
BOOL
 
InIn
();

40 
DECLARE_MESSAGE_MAP
()

	@ConfigDialog.h

1 #i!
defed
(
AFX_CONFIGDIALOG_H__5E887A2B_8CCA_4DDD_B20A_14333A1EA84C__INCLUDED_
)

2 
	#AFX_CONFIGDIALOG_H__5E887A2B_8CCA_4DDD_B20A_14333A1EA84C__INCLUDED_


	)

4 #i
_MSC_VER
 > 1000

5 #agm



13 as
	cCCfigDlog
 : 
public
 
CDlog


16 
public
:

17 
CCfigDlog
(
CWnd
* 
pPt
 = 
NULL
);

21 um { 
	mIDD
 = 
IDD_CONFIG_DIALOG
 };

29 
	geed
:

30 
vtu
 
DoDaExchge
(
CDaExchge
* 
pDX
);

34 
	geed
:

40 
DECLARE_MESSAGE_MAP
()

	@Error.h

5 #i!
defed
(
AFX_ERROR_H__8D3D34FA_3024_4D5F_81B6_D01841D85268__INCLUDED_
)

6 
	#AFX_ERROR_H__8D3D34FA_3024_4D5F_81B6_D01841D85268__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



14 
	eEID
 {

16 
	mNO_ERR
=0,

17 
	mTEST_ERR
=1,

18 
	mTEST_TRACE
=2,

21 
	mESTOP
=10,

25 
	mSENSOR
=100,

26 
	mSS_DT5V_LOW
,

27 
	mSS_DT12V_LOW
,

28 
	mSS_DT24V_LOW
,

29 
	mSS_DTHV_LOW
,

30 
	mSS_DT5VB_A_LOW
,

31 
	mSS_DT5VC_A_LOW
,

32 
	mSS_DT5VB_B_LOW
,

33 
	mSS_DT5VC_B_LOW
,

34 
	mSS_DT5VB_C_LOW
,

35 
	mSS_DT5VC_C_LOW
,

36 
	mSS_DT5VB_D_LOW
,

37 
	mSS_DT5VC_D_LOW
,

38 
	mSS_DT5VB_E_LOW
,

39 
	mSS_DT5VC_E_LOW
,

40 
	mSS_DT5VB_F_LOW
,

41 
	mSS_DT5VC_F_LOW
,

42 
	mSS_DT5VB_G_LOW
,

43 
	mSS_DT5VC_G_LOW
,

44 
	mSS_DT5VB_H_LOW
,

45 
	mSS_DT5VC_H_LOW
,

48 
	mSGNI
=400,

51 
	mFLAG
=500,

52 
	mFLAG_SOURCE_OR_SINK_CANNOT_ON
,

53 
	mFLAG_SOURCE_CANNOT_OFF
,

54 
	mFLAG_SINK_CANNOT_OFF
,

55 
	mFLAG_SOURCE_LEAK
,

56 
	mFLAG_SINK_LEAK
,

57 
	mFLAG_ODD_SOURCE_LEAK
,

58 
	mFLAG_EVEN_SOURCE_LEAK
,

60 
	mFLAG_FILE_NOT_FOUND
,

61 
	mFLAG_FILE_CANNOT_OPEN
,

62 
	mFLAG_FILE_UNPROPER_PARAMETER
,

63 
	mFLAG_FILE_CHECK_SUM
,

68 
	mINVALID_RETURN
=600,

71 
	mINVALID_INPUT
=601,

74 
	mUSER_ERR
=650,

77 
	mRANGE_OVER
=700,

78 
	mOL_REF_CURRENT_IS_OVER_INPUT_VOLT_N_RGST
,

79 
	mOL_I_RANGE_OVER
,

80 
	mOL_I_RANGE_UNDER
,

81 
	mCAL_CHECK_TEST_CONDITION
,

82 
	mCAL_CHECK_HW
,

84 
	mSW_LOGIC_ERR
 = 750,

85 
	mSW_NO_INIT_VAR
,

86 
	mMAN_ERR_TEST_CONDEITION
,

89 
	mOVERTIME
=800,

90 
	mOT_SETNCHK
,

91 
	mOT_VB_OUTCHECK_ERR
,

94 
	mDEVICE
=1000,

96 
	mMOTION
=
DEVICE
+100,

97 
	mDIO_INIT_ERR
,

98 
	mDIO_EXIT_ERR
,

99 
	mINVALID_RETURN_DIOINPBIT
,

100 
	mINVALID_RETURN_DIOOUTBIT
,

101 
	mINVALID_RETURN_DIOINPBYTE
,

102 
	mINVALID_RETURN_DIOOUTBYTE
,

103 
	mINVALID_RETURN_DIOINP_MBIT
,

104 
	mINVALID_RETURN_DIOOUT_MBIT
,

109 
	mr_no
;

110 cڡ * 
	mt
;

111 cڡ * 
	me
;

112 cڡ * 
	ms
;

113 } 
	tsEMsg
;

115 
sEMsg
 
	gEMsgTab
[] =

117 { 
NO_ERR
, "Normal", "", "" },

118 { 
TEST_ERR
, "Test", "", "" },

119 { 
TEST_TRACE
, "Test Trace", "", "" },

121 { 
ESTOP
, "E-Stop", "", "" },

123 { 
SENSOR
, "Sensor", "", "" },

124 { 
SS_DT5V_LOW
 , "5V  ̻", "", "" },

125 { 
SS_DT12V_LOW
, "12V  ̻", "", "" },

126 { 
SS_DT24V_LOW
, "24V  ̻", "", "" },

127 { 
SS_DTHV_LOW
 , "HV  ̻", "", "" },

129 { 
SS_DT5VB_A_LOW
, "BOX A 5VB  ̻", "" , "" },

130 { 
SS_DT5VC_A_LOW
, "BOX A 5VC  ̻", "" , "" },

131 { 
SS_DT5VB_B_LOW
, "BOX B 5VB  ̻", "" , "" },

132 { 
SS_DT5VC_B_LOW
, "BOX B 5VC  ̻", "" , "" },

133 { 
SS_DT5VB_C_LOW
, "BOX C 5VB  ̻", "" , "" },

134 { 
SS_DT5VC_C_LOW
, "BOX C 5VC  ̻", "" , "" },

135 { 
SS_DT5VB_D_LOW
, "BOX D 5VB  ̻", "" , "" },

136 { 
SS_DT5VC_D_LOW
, "BOX D 5VC  ̻", "" , "" },

137 { 
SS_DT5VB_E_LOW
, "BOX E 5VB  ̻", "" , "" },

138 { 
SS_DT5VC_E_LOW
, "BOX E 5VC  ̻", "" , "" },

139 { 
SS_DT5VB_F_LOW
, "BOX F 5VB  ̻", "" , "" },

140 { 
SS_DT5VC_F_LOW
, "BOX F 5VC  ̻", "" , "" },

141 { 
SS_DT5VB_G_LOW
, "BOX G 5VB  ̻", "" , "" },

142 { 
SS_DT5VC_G_LOW
, "BOX G 5VC  ̻", "" , "" },

143 { 
SS_DT5VB_H_LOW
, "BOX H 5VB  ̻", "" , "" },

144 { 
SS_DT5VC_H_LOW
, "BOX H 5VC  ̻", "" , "" },

146 { 
SGNI
, "Signal", "", "" },

148 { 
FLAG
, "Flag", "", "" },

150 { 
FLAG_SOURCE_OR_SINK_CANNOT_ON
, "Source/Sink ON ̻", "", "" },

151 { 
FLAG_SOURCE_CANNOT_OFF
, "Source OFF ̻", "", "" },

152 { 
FLAG_SINK_CANNOT_OFF
, "Sink OFF ̻", "", "" },

153 { 
FLAG_SOURCE_LEAK
, "Source Leak ̻", "", "" },

154 { 
FLAG_SINK_LEAK
, "Sink Leak ̻", "", "" },

155 { 
FLAG_ODD_SOURCE_LEAK
, "Odd Source Leak ̻", "", "" },

156 { 
FLAG_EVEN_SOURCE_LEAK
, "Even Source Leak ̻", "", "" },

158 { 
FLAG_FILE_NOT_FOUND
, " ã  ", "", "" },

159 { 
FLAG_FILE_CANNOT_OPEN
, "  ̻", "", "" },

160 { 
FLAG_FILE_UNPROPER_PARAMETER
, "  ̻", "", "" },

161 { 
FLAG_FILE_CHECK_SUM
, " CheckSum ̻", "", "" },

165 { 
INVALID_RETURN
, "Invalideturn", "", "" },

166 { 
INVALID_INPUT
, "Invalid Input Parameter", "", "" },

168 { 
USER_ERR
, "  ", "", "" },

170 { 
RANGE_OVER
, "Range Over", "", "" },

171 { 
OL_REF_CURRENT_IS_OVER_INPUT_VOLT_N_RGST
, "   ̻", "", "" },

172 { 
OL_I_RANGE_OVER
, "ִ    ʰ", "", "" },

173 { 
OL_I_RANGE_UNDER
, "ּ    ʰ", "", "" },

174 { 
CAL_CHECK_TEST_CONDITION
, "Calibration Test Condtion   üũ ʿ", "", "" },

175 { 
CAL_CHECK_HW
, "Calibration Hw Read  ̻. H/W üũ ʿ", "", "" },

177 { 
SW_LOGIC_ERR
, "SW   . S/Wüũ ʿ", "", "" },

178 { 
SW_NO_INIT_VAR
, "ʱȭ   . S/W üũ ʿ", "", "" },

179 { 
MAN_ERR_TEST_CONDEITION
, "ManulTest   ̻", "", "" },

181 { 
OVERTIME
, "Overime", "", "" },

182 { 
OT_SETNCHK
, "Souce м ̻", "", "" },

183 { 
OT_VB_OUTCHECK_ERR
, "VB OUT CHECK ERROR. OverTime", "", "" },

186 { 
DEVICE
, "Device", "", "" },

187 { 
MOTION
, "Motion", "", "" },

188 { 
DIO_INIT_ERR
, "DIO_INIT_ERR", "", "" },

189 { 
DIO_EXIT_ERR
, "DIO_EXIT_ERR", "", "" },

190 { 
INVALID_RETURN_DIOINPBIT
, "Invalideturn from DioInpBit()", "", "" },

191 { 
INVALID_RETURN_DIOOUTBIT
, "Invalideturn from DioOutBit()", "", "" },

192 { 
INVALID_RETURN_DIOINPBYTE
, "Invalideturn from DioInpByte()", "", "" },

193 { 
INVALID_RETURN_DIOOUTBYTE
, "Invalideturn from DioOutByte()", "", "" },

194 { 
INVALID_RETURN_DIOINP_MBIT
, "Invalideturn from DioInpMultiBit()", "", "" },

195 { 
INVALID_RETURN_DIOOUT_MBIT
, "Invalideturn from DioOutMultiBit()", "", "" },

199 
	#ERRMSG_TABLE_LEN
 (
EMsgTab
)/(EMsgTab[0])

	)

202 as
	cCE


204 
	mive
:

205 
m_r_no
;

207 
	mpublic
:

208 
CSg
 
m_rS
;

210 
S
(
rcode
, 
CSg
 
rS
="");

211 
	$G
()

214  
m_r_no
;

216 
	`Ret
();

217 
BOOL
 
	`GMsg
(
r_no
, 
CSg
 &
t
, CSg &
e
, CSg &
s
);

219 
public
:

220 
	`CE
();

221 
vtu
 ~
	`CE
();

222 
	}
};

225 
CE
 
ERR
;

227 
EMsg
(
nMboxTy
=
MB_OK
, 
BOOL
 
bTOn
=
TRUE
);

	@Globals.h

5 #i!
defed
(
AFX_GLOBALS_H__FDA16379_4221_4970_8471_B8FBD39D2C1E__INCLUDED_
)

6 
	#AFX_GLOBALS_H__FDA16379_4221_4970_8471_B8FBD39D2C1E__INCLUDED_


	)

8 #i
_MSC_VER
 > 1000

9 #agm



12 
	~<de.h
>

13 
	~<io.h
>

14 
	~"dafx.h
"

15 
	~<dg.h
>

23 
	#FUNC
(

#

	)

28 as
	cCGlobs


30 
	mpublic
:

31 
CGlobs
();

32 
	mvtu
 ~
CGlobs
();

43 
	ssFILE_DATA


45 
CSg
 
	mSyemD
;

46 
CSg
 
	mPamD
;

47 
CSg
 
	mDaD
;

50 
CSg
 
	mACE400_4WDaD
;

52 
CSg
 
	mSyemFeName
;

53 
CSg
 
	mSyemFe
;

55 
sFILE_DATA
()

57 
	mSyemFeName
 = "System.";

59 
	mACE400_4WDaD
 = "D:\\log4w";

62 
In
()

65 
	mbufr
[
_MAX_PATH
];

66 if(
_gcwd

bufr
, 
_MAX_PATH
 ) =
NULL
)

68 
AfxMesgeBox
("Root directoryot found.");

72 
	mSyemD
.
Fm
("%s", 
bufr
);

74 
	mDaD
 = 
SyemD
 + "\\" + "Data";

77 if(
_acss
(
DaD
, 0 )) == -1 )

78 
_mkd
(
DaD
);

80 
	mSyemFe
 = 
PamD
 + "\\" + 
SyemFeName
;

83 } 
	tsFILE_DATA
;

91 
	eUNIT
 { 
	mc
=0, 
	mmc
=1, 
	muc
=2, 
	mmA
, 
	muA
, 
	mMohm
, 
	mKohm
, 
	mohm
, 
	mmohm
, 
	muohm
 };

92 
	eUNIT_CONVERT_TYPE
 {

93 
	mMM_TO_UM
, 
	mUM_TO_MM
, 
	mSEC_TO_MSEC
, 
	mMSEC_TO_SEC


96 
	ePRT_TYPE
 { 
	mPRT_BASIC
,

97 
	mPRT_LEVEL1
,

98 
	mPRT_LEVEL2
,

99 
	mPRT_LEVEL3
,

100 
	mPRT_DEVICE
,

101 
	mPRT_DEV_D64
,

106 
WORD
 
g_wPrtS
;

107 
sFILE_DATA
 
g_sFe
;

119 
DoEvts
(
DWORD
 
dwMlicds
=0);

120 
Day
(
UINT
 
daytime
=0, UINT 
un
=
uc
);

121 
__t64
 
GMioSecd
();

122 
BOOL
 
FeExis
(
CSg
 
rFePh
);

123 
GDeAndTime
(*
dime
);

124 
SIZE_T
 
GProssWkgSSize
();

125 
__PrtMemSize
(* 
rFunc
, 
le
);

126 
__PrtLe
(* 
rFe
, 
le
);

127 
	#__LINE_PRT__
 (
	`__PrtLe
(
__FILE__
, 
__LINE__
));

	)

129 
AFX_CDECL
 
MyT
(
PRT_TYPE
 
tTy
, 
LPCTSTR
 
szFm
, ...);

131 
p_tdi
(
t
, 
df
);

	@ShortTestDialog.h

1 #i!
defed
(
AFX_SHORT_TEST_DIALOG_H__2ECC17B6_A785_4CA6_B46A_85C1648A9469__INCLUDED_
)

2 
	#AFX_SHORT_TEST_DIALOG_H__2ECC17B6_A785_4CA6_B46A_85C1648A9469__INCLUDED_


	)

4 #i
_MSC_VER
 > 1000

5 #agm



10 
	~"Globs.h
"

11 
	~"E.h
"

14 
	#MAX_SQUARE_N
 100

	)

16 as
	cCPLi


19 
	mpublic
:

20 
waP
[
MAX_SQUARE_N
];

21 
	mnPC
;

24 
	mpublic
:

25 
	$CPLi
()

27 ::
	`FlMemy
(
waP
, (waPin), -1);

28 
nPC
 = 0;

31 
	$Memb
()

33 ::
	`FlMemy
(
waP
, (waPin), -1);

34 
nPC
 = 0;

35 
	}
}

38 
BOOL
 
	$isExi
(
wP
)

40 
i
 = 0; i < 
nPC
; i++)

42 i(
waP
[
i
] =
wP
)

43  
TRUE
;

45  
FALSE
;

46 
	}
}

48 
BOOL
 
	$isEmy
()

50 i(
nPC
 == 0)

51  
TRUE
;

53 i(
waP
[0] == -1)

54  
TRUE
;

56  
FALSE
;

57 
	}
}

60 
	$addPLi
(
wP
)

62 i(
nPC
 >
MAX_SQUARE_N
)

65 i(
	`isExi
(
wP
=
TRUE
)

68 
waP
[
nPC
] = 
wP
;

70 
nPC
++;

73 
	}
}

75 
CSg
 
	$gS_PLi
()

77 
CSg
 
out
 = "";

78 
CSg
 
rTemp
 = "";

80 
i
 = 0; i < 
nPC
; i++)

82 
rTemp
.
	`Fm
" %5d", 
waP
[
i
]);

83 
out
 +
rTemp
;

86  
out
;

87 
	}
}

95 as
	cCShtTeDlog
 : 
public
 
CDlog


98 
public
:

99 
CShtTeDlog
(
CWnd
* 
pPt
 = 
NULL
);

103 um { 
	mIDD
 = 
IDD_SHORT_TEST_DIALOG
 };

104 
CLiBox
 
	gm_liBadP
;

105 
CEd
 
	gm_edSqueMx
;

106 
CEd
 
	gm_edMsOut
;

107 
	gm_ed_nSquePNum
;

108 
	gm_ed_nSqueN
;

109 
	gm_ed_nShtVbIut
;

110 
	gm_ed_nShtVcIut
;

111 
	gm_ed_nBadPIut
;

112 
BOOL
 
	gm_check_bLr
;

113 
BOOL
 
	gm_check_bExudeVc
;

120 
	geed
:

121 
vtu
 
DoDaExchge
(
CDaExchge
* 
pDX
);

125 
	geed
:

129 
vtu
 
BOOL
 
OnInDlog
();

130 
afx_msg
 
OnBuIutSquePNum
();

131 
afx_msg
 
OnBuAddBadP
();

132 
afx_msg
 
OnBuRetBadP
();

133 
afx_msg
 
OnBuMsuSht
();

135 
	$DECLARE_MESSAGE_MAP
()

137 
public
:

142 
m_waSqueMrix
[
MAX_SQUARE_N
][MAX_SQUARE_N];

143 
CPLi
 
m_Bad
;

145 
CPLi
 
m_foundVbBad
;

146 
CPLi
 
m_foundVcBad
;

147 
CPLi
 
m_foundExaVbBad
;

148 
BOOL
 
m_bFg_RegiVcBad
;

149 
BOOL
 
m_bFg_RegiVbBad
;

150 
BOOL
 
m_bFgSQMrxChged
;

153 
m_waVbOn
[
MAX_SQUARE_N
];

154 
m_nVbCou
;

155 
m_waVcOn
[
MAX_SQUARE_N
];

156 
m_nVcCou
;

157 
m_nCheckSht_Cou
;

164 
BOOL
 
	`InMemb
();

167 
	`makeSque
();

168 
CSg
 
	`tSque
();

169 
	`tSque_T
();

172 
	`DoCheck_YD
(
CSg
 &
rOut
);

173 
	`BSrch_VbCheck
(
CSg
 &
rOut
, 
vbF
, 
vbLa
, 
vcF
, 
vcLa
, 
BOOL
 
bFCl

FALSE
);

174 
	`LSrch_VbCheck
(
CSg
 &
rOut
, 
vbF
, 
vbLa
, 
vcF
, 
vcLa
);

175 
	`BSrch_VcCheck
(
CSg
 &
rOut
, 
vbF
, 
vbLa
, 
vcF
, 
vcLa
, 
BOOL
 
bFCl

FALSE
);

176 
	`LSrch_VcCheck
(
CSg
 &
rOut
, 
vbF
, 
vbLa
, 
vcF
, 
vcLa
);

177 
	`AddVbBad_PLi
(
wP
);

178 
	`AddVcBad_PLi
(
wP
);

181 
	`DoCheck_XD
(
CSg
 &
rOut
);

182 
	`CumnLeSrch
(
CSg
& 
rOut
, 
vcC
);

185 
	`CheckSht
(
vbF
, 
vbLa
, 
vcF
, 
vcLa
);

186 
	`VB_SwOn
(
wVbP
);

187 
	`VC_SwOn
(
wVcP
);

188 
	`VB_Ret
();

189 
	`VC_Ret
();

190 
CSg
 
	`VB_Prt
(
t
, 
d
);

191 
CSg
 
	`VC_Prt
(
t
, 
d
);

192 
	`VB_PrtT
();

193 
	`VC_PrtT
();

195 
	}
};

	@StdAfx.h

6 #i!
defed
(
AFX_STDAFX_H__162EFA7F_2283_401E_A2DD_16AA1B7EE8C3__INCLUDED_
)

7 
	#AFX_STDAFX_H__162EFA7F_2283_401E_A2DD_16AA1B7EE8C3__INCLUDED_


	)

9 #i
_MSC_VER
 > 1000

10 #agm



13 
	#VC_EXTRALEAN


14 

	)

15 
	~<afxw.h
>

16 
	~<afxext.h
>

17 
	~<afxdi.h
>

18 
	~<afxdtl.h
>

19 #ide
_AFX_NO_AFXCMN_SUPPORT


20 
	~<afxcmn.h
>

	@gridctrl_src/CellRange.h

5 #i!
defed
(
AFX_CELLRANGE_H__F86EF761_725A_11D1_ABBA_00A0243D1382__INCLUDED_
)

6 
	#AFX_CELLRANGE_H__F86EF761_725A_11D1_ABBA_00A0243D1382__INCLUDED_


	)

8 #i
_MSC_VER
 >= 1000

9 #agm



17 as
	cCClID


20 
	mpublic
:

21 
row
, 
	mc
;

24 
	mpublic
:

25 
CClID
(
nRow
 = -1, 
nC
 = -1: 
row
Row), 
	$c
(
nC
) {}

27 
	$IsVid
(cڡ {  (
row
 >0 && 
c
 >0); 
	}
}

28 
	gݔ
==(cڡ 
CClID
& 
rhs
{  (
row
 =rhs.row && 
c
 ==hs.col); }

29 
	gݔ
!=(cڡ 
CClID
& 
rhs
{  !
ݔ
==(rhs); }

32 as
	cCClRge


34 
	mpublic
:

36 
CClRge
(
nMRow
 = -1, 
nMC
 = -1, 
nMaxRow
 = -1, 
nMaxC
 = -1)

38 
S
(
nMRow
, 
nMC
, 
nMaxRow
, 
nMaxC
);

41 
S
(
nMRow
 = -1, 
nMC
 = -1, 
nMaxRow
 = -1, 
nMaxC
 = -1);

43 
	$IsVid
() const;

44 
	$InRge
(
row
, 
c
) const;

45 
	$InRge
(cڡ 
CClID
& 
ID
) const;

46 
	$Cou
({  (
m_nMaxRow
 - 
m_nMRow
 + 1* (
m_nMaxC
 - 
m_nMC
 + 1); 
	}
}

48 
CClID
 
	$GTLe
() const;

49 
CClRge
 
	$I
(cڡ 
CClRge
& 
rhs
) const;

51 
	$GMRow
(cڡ { 
m_nMRow
;
	}
}

52 
	$SMRow
(
mRow
{
m_nMRow
 = mRow;
	}
}

54 
	$GMC
(cڡ { 
m_nMC
;
	}
}

55 
	$SMC
(
mC
{
m_nMC
 = mC;
	}
}

57 
	$GMaxRow
(cڡ { 
m_nMaxRow
;
	}
}

58 
	$SMaxRow
(
maxRow
{
m_nMaxRow
 = maxRow;
	}
}

60 
	$GMaxC
(cڡ { 
m_nMaxC
;
	}
}

61 
	$SMaxC
(
maxC
{
m_nMaxC
 = maxC;
	}
}

63 
	$GRowSn
(cڡ { 
m_nMaxRow
 - 
m_nMRow
 + 1;
	}
}

64 
	$GCSn
(cڡ { 
m_nMaxC
 - 
m_nMC
 + 1;
	}
}

66 
	gݔ
==(cڡ 
CClRge
& 
rhs
);

67 
	gݔ
!=(cڡ 
CClRge
& 
rhs
);

69 
	geed
:

70 
m_nMRow
;

71 
	gm_nMC
;

72 
	gm_nMaxRow
;

73 
	gm_nMaxC
;

76 
le
 
	gCClRge
::
	$S
(
mRow
, 
mC
, 
maxRow
, 
maxC
)

78 
m_nMRow
 = 
mRow
;

79 
m_nMC
 = 
mC
;

80 
m_nMaxRow
 = 
maxRow
;

81 
m_nMaxC
 = 
maxC
;

82 
	}
}

84 
le
 
	gCClRge
::
ݔ
==(cڡ 
CClRge
& 
rhs
)

86  ((
m_nMRow
 =
rhs
.m_nMRow&& (
m_nMC
 ==hs.m_nMinCol) &&

87 (
m_nMaxRow
 =
rhs
.m_nMaxRow&& (
m_nMaxC
 ==hs.m_nMaxCol));

90 
le
 
	gCClRge
::
ݔ
!=(cڡ 
CClRge
& 
rhs
)

92  !
ݔ
==(
rhs
);

95 
le
 
	gCClRge
::
	$IsVid
() const

97  (
m_nMRow
 >0 && 
m_nMC
 >0 && 
m_nMaxRow
 >0 && 
m_nMaxC
 >= 0 &&

98 
m_nMRow
 <
m_nMaxRow
 && 
m_nMC
 <
m_nMaxC
);

99 
	}
}

101 
le
 
	gCClRge
::
	$InRge
(
row
, 
c
) const

103  (
row
 >
m_nMRow
 &&ow <
m_nMaxRow
 && 
c
 >
m_nMC
 && c <
m_nMaxC
);

104 
	}
}

106 
le
 
	gCClRge
::
	$InRge
(cڡ 
CClID
& 
ID
) const

108  
	`InRge
(
ID
.
row
, clID.
c
);

109 
	}
}

111 
le
 
CClID
 
	gCClRge
::
	$GTLe
() const

113  
	`CClID
(
m_nMRow
, 
m_nMC
);

114 
	}
}

116 
le
 
CClRge
 
	gCClRge
::
	$I
(cڡ 
CClRge
& 
rhs
) const

118  
	`CClRge
(
	`max
(
m_nMRow
,
rhs
.m_nMRow), max(
m_nMC
,rhs.m_nMinCol),

119 
	`m
(
m_nMaxRow
,
rhs
.m_nMaxRow), m(
m_nMaxC
,rhs.m_nMaxCol));

120 
	}
}

	@gridctrl_src/GridCtrl.h

1 #i!
defed
(
AFX_GRIDCTRL_H__519FA702_722C_11D1_ABBA_00A0243D1382__INCLUDED_
)

2 
	#AFX_GRIDCTRL_H__519FA702_722C_11D1_ABBA_00A0243D1382__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



48 
	~"ClRge.h
"

49 
	~<afxm.h
>

51 #ifde
_WIN32_WCE


52 
	#GRIDCONTROL_NO_TITLETIPS


53 
	#GRIDCONTROL_NO_DRAGDROP


54 
	#GRIDCONTROL_NO_CLIPBOARD


55 
	#GRIDCONTROL_NO_PRINTING


56 

	)

57 #ifde
WCE_NO_PRINTING


58 
	#_WIN32_WCE_NO_PRINTING


	)

60 #ifde
WCE_NO_CURSOR


61 
	#_WIN32_WCE_NO_CURSOR


	)

66 #unde
TRY


67 #unde
CATCH


68 #unde
END_CATCH


69 
	#TRY
 
y


	)

70 
	#CATCH
(
ex_ass
, 
ex_obje

	`tch
x_ass*x_obje)

	)

71 
	#END_CATCH


	)

74 #ide
GRIDCONTROL_NO_TITLETIPS


75 
	~"TT.h
"

78 #ide
GRIDCONTROL_NO_DRAGDROP


79 
	~"GridDrTg.h
"

80 #unde
GRIDCONTROL_NO_CLIPBOARD


83 #ide
GRIDCONTROL_NO_CLIPBOARD


84 
	~<afxe.h
>

89 
	#GRIDCTRL_CLASSNAME
 
	`_T
("MFCGridCtrl")

90 
	#IDC_INPLACE_CONTROL
 8

91 

	)

92 
	#IsSHIFTesd
((
	`GKeyS
(
VK_SHIFT
& (1 << ((
SHORT
)*8-1))!0 )

	)

93 
	#IsCTRLesd
((
	`GKeyS
(
VK_CONTROL
& (1 << ((
SHORT
)*8-1))!0 )

	)

96 
	s_GV_ITEM
 {

97 
	mrow
,
	mc
;

98 
UINT
 
	mmask
;

99 
UINT
 
	me
;

100 
UINT
 
	mnFm
;

101 
CSg
 
	mszText
;

102 
	miImage
;

103 
COLORREF
 
	mBkC
;

104 
COLORREF
 
	mFgC
;

105 
LPARAM
 
	mlPam
;

106 
LOGFONT
 
	mlfFt
;

107 } 
	tGV_ITEM
;

110 
	#GVL_NONE
 0

	)

111 
	#GVL_HORZ
 1

	)

112 
	#GVL_VERT
 2

	)

113 
	#GVL_BOTH
 3

	)

116 
	#GVIF_TEXT
 
LVIF_TEXT


	)

117 
	#GVIF_IMAGE
 
LVIF_IMAGE


	)

118 
	#GVIF_PARAM
 
LVIF_PARAM


	)

119 
	#GVIF_STATE
 
LVIF_STATE


	)

120 
	#GVIF_BKCLR
 (
GVIF_STATE
<<1)

	)

121 
	#GVIF_FGCLR
 (
GVIF_STATE
<<2)

	)

122 
	#GVIF_FORMAT
 (
GVIF_STATE
<<3)

	)

123 
	#GVIF_FONT
 (
GVIF_STATE
<<4)

	)

126 
	#GVIS_FOCUSED
 0x0001

	)

127 
	#GVIS_SELECTED
 0x0002

	)

128 
	#GVIS_DROPHILITED
 0x0004

	)

129 
	#GVIS_READONLY
 0x0008

	)

130 
	#GVIS_FIXED
 0x0010

131 
	#GVIS_MODIFIED
 0x0020

	)

134 
	#GVNI_FOCUSED
 0x0001

	)

135 
	#GVNI_SELECTED
 0x0002

	)

136 
	#GVNI_DROPHILITED
 0x0004

	)

137 
	#GVNI_READONLY
 0x0008

	)

138 
	#GVNI_FIXED
 0x0010

139 
	#GVNI_MODIFIED
 0x0020

	)

141 
	#GVNI_ABOVE
 
LVNI_ABOVE


	)

142 
	#GVNI_BELOW
 
LVNI_BELOW


	)

143 
	#GVNI_TOLEFT
 
LVNI_TOLEFT


	)

144 
	#GVNI_TORIGHT
 
LVNI_TORIGHT


	)

145 
	#GVNI_ALL
 (
LVNI_BELOW
|
LVNI_TORIGHT
|
LVNI_TOLEFT
)

	)

146 
	#GVNI_AREA
 (
LVNI_BELOW
|
LVNI_TORIGHT
)

	)

149 
	#GVHT_DATA
 0x0000

	)

150 
	#GVHT_TOPLEFT
 0x0001

	)

151 
	#GVHT_COLHDR
 0x0002

	)

152 
	#GVHT_ROWHDR
 0x0004

	)

153 
	#GVHT_COLSIZER
 0x0008

	)

154 
	#GVHT_ROWSIZER
 0x0010

	)

155 
	#GVHT_LEFT
 0x0020

	)

156 
	#GVHT_RIGHT
 0x0040

	)

157 
	#GVHT_ABOVE
 0x0080

	)

158 
	#GVHT_BELOW
 0x0100

	)

160 
	sgNM_GRIDVIEW
 {

161 
NMHDR
 
	mhdr
;

162 
	miRow
;

163 
	miCumn
;

164 } 
	tNM_GRIDVIEW
;

166 
	sgGV_DISPINFO
 {

167 
NMHDR
 
	mhdr
;

168 
GV_ITEM
 
	mem
;

169 } 
	tGV_DISPINFO
;

172 
	#GVN_BEGINDRAG
 
LVN_BEGINDRAG


173 
	#GVN_BEGINLABELEDIT
 
LVN_BEGINLABELEDIT


174 
	#GVN_BEGINRDRAG
 
LVN_BEGINRDRAG


	)

175 
	#GVN_COLUMNCLICK
 
LVN_COLUMNCLICK


	)

176 
	#GVN_DELETEITEM
 
LVN_DELETEITEM


	)

177 
	#GVN_ENDLABELEDIT
 
LVN_ENDLABELEDIT


178 
	#GVN_SELCHANGING
 
LVN_ITEMCHANGING


	)

179 
	#GVN_SELCHANGED
 
LVN_ITEMCHANGED


	)

187 as
	cCGridCl
 : 
public
 
CObje


189 
public
:

190 
	$CGridCl
()

192 
e
 = 0;

193 
nFm
 = 0;

194 
szText
.
	`Emy
();

195 
iImage
 = -1;

196 
BkC
 = 
CLR_DEFAULT
;

197 
FgC
 = 
CLR_DEFAULT
;

198 
lPam
 = 0;

201 
UINT
 
e
;

202 
UINT
 
nFm
;

203 
CSg
 
szText
;

204 
iImage
;

205 
COLORREF
 
BkC
;

206 
COLORREF
 
FgC
;

207 
LOGFONT
 
lfFt
;

208 
LPARAM
 
lPam
;

209 
	}
};

213 
	gCTydPAay
<
	tCObAay
, 
	tCGridCl
*> 
	tGRID_ROW
;

219 
ass
 
	gCGridCl
;

220 
AFXAPI
 
DDX_GridCڌ
(
CDaExchge
* 
pDX
, 
nIDC
, 
CGridCl
& 
rCڌ
);

225 as
	cCGridCl
 : 
public
 
CWnd


227 
	$DECLARE_DYNCREATE
(
CGridCl
)

230 
public
:

231 
	`CGridCl
(
nRows
 = 0, 
nCs
 = 0, 
nFixedRows
 = 0, 
nFixedCs
 = 0);

233 
BOOL
 
	`Ce
(cڡ 
RECT
& 

, 
CWnd
* 

, 
UINT
 
nID
,

234 
DWORD
 
dwSty
 = 
WS_CHILD
 | 
WS_BORDER
 | 
WS_TABSTOP
 | 
WS_VISIBLE
);

235 
BOOL
 
	`SubassWdow
(
HWND
 
hWnd
);

238 
public
:

239 
	$GRowCou
(cڡ {  
m_nRows
; }

240 
	$GCumnCou
(cڡ {  
m_nCs
; 
	}
}

241 
	$GFixedRowCou
(cڡ {  
m_nFixedRows
; 
	}
}

242 
	$GFixedCumnCou
(cڡ {  
m_nFixedCs
; 
	}
}

243 
BOOL
 
SRowCou
(
nRows
 = 10);

244 
BOOL
 
SCumnCou
(
nCs
 = 10);

245 
BOOL
 
SFixedRowCou
(
nFixedRows
 = 1);

246 
BOOL
 
SFixedCumnCou
(
nFixedCs
 = 1);

248 
	$GRowHeight
(
nRow
) const;

249 
BOOL
 
	`SRowHeight
(
row
, 
height
);

250 
	$GCumnWidth
(
nC
) const;

251 
BOOL
 
	`SCumnWidth
(
c
, 
width
);

253 
BOOL
 
	$GClOrig
(
nRow
, 
nC
, 
LPPOINT
 
p
) const;

254 
BOOL
 
	$GClOrig
(cڡ 
CClID
& 

, 
LPPOINT
 
p
) const;

255 
BOOL
 
	$GClRe
(
nRow
, 
nC
, 
LPRECT
 
pRe
) const;

256 
BOOL
 
	$GClRe
(cڡ 
CClID
& 

, 
LPRECT
 
pRe
) const;

258 
BOOL
 
	`GTextRe
(cڡ 
CClID
& 

, 
LPRECT
 
pRe
);

259 
BOOL
 
	`GTextRe
(
nRow
, 
nC
, 
LPRECT
 
pRe
);

261 
	$GFixedRowHeight
() const;

262 
	$GFixedCumnWidth
() const;

263 
	$GVtuWidth
() const;

264 
	$GVtuHeight
() const;

266 
	$STextC
(
COLORREF
 
r
{ 
m_TextCour
 = c; 
	}
}

267 
COLORREF
 
	$GTextC
(cڡ {  
m_TextCour
; 
	}
}

268 
	$STextBkC
(
COLORREF
 
r
{ 
m_TextBkCour
 = c; 
	}
}

269 
COLORREF
 
	$GTextBkC
(cڡ {  
m_TextBkCour
; 
	}
}

270 
	$SBkC
(
COLORREF
 
r
{ 
m_BkCour
 = c; 
	}
}

271 
COLORREF
 
	$GBkC
(cڡ {  
m_BkCour
; 
	}
}

272 
	$SFixedTextC
(
COLORREF
 
r
{ 
m_FixedTextCour
 = c; 
	}
}

273 
COLORREF
 
	$GFixedTextC
(cڡ {  
m_FixedTextCour
; 
	}
}

274 
	$SFixedBkC
(
COLORREF
 
r
{ 
m_FixedBkCour
 = c; 
	}
}

275 
COLORREF
 
	$GFixedBkC
(cڡ {  
m_FixedBkCour
; 
	}
}

276 
	$SGridC
(
COLORREF
 
r
{ 
m_GridCour
 = c; 
	}
}

277 
COLORREF
 
	$GGridC
(cڡ {  
m_GridCour
; 
	}
}

279 
	$GSeedCou
(cڡ {  
m_SeedClM
.
	`GCou
(); 
	}
}

281 
CClID
 
	$GFocusCl
(cڡ {  
m_idCutCl
; 
	}
}

283 
	$SImageLi
(
CImageLi
* 
pLi
{ 
m_pImageLi
 =Li; 
	}
}

284 
CImageLi
* 
	$GImageLi
(cڡ {  
m_pImageLi
; 
	}
}

286 
	$SGridLes
(
nWhichLes
 = 
GVL_BOTH
{ 
m_nGridLes
 =WhichLines;

287 i(::
	`IsWdow
(
	`GSaHwnd
())
	`Invide
(); 
	}
}

288 
	$GGridLes
(cڡ {  
m_nGridLes
; 
	}
}

290 
	$SEdab
(
BOOL
 
bEdab
 = 
TRUE
{ 
m_bEdab
 = bEdab; 
	}
}

291 
BOOL
 
	$IsEdab
(cڡ {  
m_bEdab
; 
	}
}

292 
	$SLiMode
(
BOOL
 
bEbLiMode
 = 
TRUE
{ 
m_bLiMode
 = bEbLiMode; 
	}
}

293 
BOOL
 
	$GLiMode
(cڡ {  
m_bLiMode
; 
	}
}

294 
	$SSgRowSei
(
BOOL
 
bSg
 = 
TRUE
{ 
m_bSgRowSei
 = bSg; 
	}
}

295 
BOOL
 
	$GSgRowSei
({  
m_bSgRowSei
; 
	}
}

296 
	$EbSei
(
BOOL
 
bEb
 = 
TRUE
{ 
	`RetSeedRge
(); 
m_bEbSei
 = bEb; RetSeedRge(); 
	}
}

297 
BOOL
 
	$IsSeab
(cڡ {  
m_bEbSei
; 
	}
}

298 
	$EbDgAndDr
(
BOOL
 
bAow
 = 
TRUE
{ 
m_bAowDgAndDr
 = bAow; 
	}
}

299 
BOOL
 
	$GDgAndDr
(cڡ {  
m_bAowDgAndDr
; 
	}
}

300 
	$SRowResize
(
BOOL
 
bResize
 = 
TRUE
{ 
m_bAowRowResize
 = bResize; 
	}
}

301 
BOOL
 
	$GRowResize
(cڡ {  
m_bAowRowResize
; 
	}
}

302 
	$SCumnResize
(
BOOL
 
bResize
 = 
TRUE
{ 
m_bAowCumnResize
 = bResize; 
	}
}

303 
BOOL
 
	$GCumnResize
(cڡ {  
m_bAowCumnResize
; 
	}
}

304 
	$SHdSt
(
BOOL
 
bStOnClick
 = 
TRUE
{ 
m_bStOnClick
 = bStOnClick; 
	}
}

305 
BOOL
 
	$GHdSt
(cڡ {  
m_bStOnClick
; 
	}
}

306 
	$SHdTabKey
(
BOOL
 
bHdTab
 = 
TRUE
{ 
m_bHdTabKey
 = bHdTab; 
	}
}

307 
BOOL
 
	$GHdTabKey
(cڡ {  
m_bHdTabKey
; 
	}
}

308 
	$SDoubBufrg
(
BOOL
 
bBufr
 = 
TRUE
{ 
m_bDoubBufr
 = bBufr; 
	}
}

309 
BOOL
 
	$GDoubBufrg
(cڡ {  
m_bDoubBufr
; 
	}
}

310 
	$EbTTs
(
BOOL
 
bEb
 = 
TRUE
{ 
m_bTTs
 = bEb; 
	}
}

311 
BOOL
 
	$GTTs
({  
m_bTTs
; 
	}
}

313 
SModifd
(
BOOL
 
bModifd
 = 
TRUE
, 
nRow
 = -1, 
nC
 = -1);

314 
BOOL
 
GModifd
(
nRow
 = -1, 
nC
 = -1);

315 
BOOL
 
IsClFixed
(
nRow
, 
nC
);

317 
BOOL
 
SIm
(cڡ 
GV_ITEM
* 
pIm
);

318 
BOOL
 
GIm
(
GV_ITEM
* 
pIm
);

319 
BOOL
 
SImText
(
nRow
, 
nC
, 
LPCTSTR
 
r
);

320 
vtu
 
CSg
 
GImText
(
nRow
, 
nC
);

321 
BOOL
 
SImDa
(
nRow
, 
nC
, 
LPARAM
 
lPam
);

322 
LPARAM
 
	$GImDa
(
nRow
, 
nC
) const;

323 
BOOL
 
	`SImImage
(
nRow
, 
nC
, 
iImage
);

324 
	$GImImage
(
nRow
, 
nC
) const;

325 
BOOL
 
	`SImS
(
nRow
, 
nC
, 
UINT
 
e
);

326 
UINT
 
	$GImS
(
nRow
, 
nC
) const;

327 
BOOL
 
	`SImFm
(
nRow
, 
nC
, 
UINT
 
nFm
);

328 
UINT
 
	$GImFm
(
nRow
, 
nC
) const;

329 
BOOL
 
	`SImBkCour
(
nRow
, 
nC
, 
COLORREF
 

 = 
CLR_DEFAULT
);

330 
COLORREF
 
	$GImBkCour
(
nRow
, 
nC
) const;

331 
BOOL
 
	`SImFgCour
(
nRow
, 
nC
, 
COLORREF
 

 = 
CLR_DEFAULT
);

332 
COLORREF
 
	$GImFgCour
(
nRow
, 
nC
) const;

333 
BOOL
 
	`SImFt
(
nRow
, 
nC
, 
LOGFONT
* 
lf
);

334 
LOGFONT
* 
	`GImFt
(
nRow
, 
nC
);

337 
public
:

338 
	`InCumn
(
LPCTSTR
 
rHdg
, 
UINT
 
nFm
 = 
DT_CENTER
|
DT_VCENTER
|
DT_SINGLELINE
,

339 
nCumn
 = -1);

340 
	`InRow
(
LPCTSTR
 
rHdg
, 
nRow
 = -1);

341 
BOOL
 
	`DeCumn
(
nCumn
);

342 
BOOL
 
	`DeRow
(
nRow
);

343 
BOOL
 
	`DeNFixedRows
();

344 
BOOL
 
	`DeAIms
();

346 
BOOL
 
	`AutoSizeRow
(
nRow
);

347 
BOOL
 
	`AutoSizeCumn
(
nC
);

348 
	`AutoSizeRows
();

349 
	`AutoSizeCumns
();

350 
	`AutoSize
();

351 
	`ExndCumnsToF
();

352 
	`ExndRowsToF
();

353 
	`ExndToF
();

355 
CSize
 
	`GTextEx
(
LPCTSTR
 
r
, 
BOOL
 
bUSeedFt
 = 
TRUE
);

356 
	$EnsuVisib
(
CClID
 &

{ 
	`EnsuVisib
(.
row
, cl.
c
); 
	}
}

357 
EnsuVisib
(
nRow
, 
nC
);

358 
BOOL
 
	$IsClVisib
(
nRow
, 
nC
) const;

359 
BOOL
 
	$IsClVisib
(
CClID
 

) const;

360 
BOOL
 
	$IsClEdab
(
nRow
, 
nC
) const;

361 
BOOL
 
	$IsClEdab
(
CClID
 &

) const;

365 
	`SRedw
(
BOOL
 
bAowDw
, BOOL 
bRetSlBs
 = 
FALSE
);

366 
BOOL
 
	`RedwCl
(
nRow
, 
nC
, 
CDC
* 
pDC
 = 
NULL
);

367 
BOOL
 
	`RedwCl
(cڡ 
CClID
& 

, 
CDC
* 
pDC
 = 
NULL
);

368 
BOOL
 
	`RedwRow
(
row
);

369 
BOOL
 
	`RedwCumn
(
c
);

371 #i!
	`defed
(
_WIN32_WCE_NO_PRINTING
&& !
	$defed
(
GRIDCONTROL_NO_PRINTING
)

372 
	`Prt
();

374 #ide
_WIN32_WCE


375 
BOOL
 
	`Save
(
LPCTSTR
 
fame
);

376 
BOOL
 
	`Ld
(
LPCTSTR
 
fame
);

379 
CClRge
 
	$GClRge
() const;

380 
CClRge
 
	$GSeedClRge
() const;

381 
	`SSeedRge
(cڡ 
CClRge
& 
Rge
, 
BOOL
 
bFRat
 = 
FALSE
);

382 
	`SSeedRge
(
nMRow
, 
nMC
, 
nMaxRow
, 
nMaxC
,

383 
BOOL
 
bFRat
 = 
FALSE
);

384 
BOOL
 
	$IsVid
(
nRow
, 
nC
) const;

385 
BOOL
 
	$IsVid
(cڡ 
CClID
& 

) const;

386 
BOOL
 
	$IsVid
(cڡ 
CClRge
& 
nge
) const;

388 #ide
GRIDCONTROL_NO_CLIPBOARD


390 
vtu
 
	`CutSeedText
();

391 
vtu
 
CODaSour
* 
	`CyTextFromGrid
();

392 
vtu
 
BOOL
 
	`PaeTextToGrid
(
CClID
 

, 
CODaObje
* 
pDaObje
);

395 #ide
GRIDCONTROL_NO_DRAGDROP


396 
	`OnBegDg
();

397 
DROPEFFECT
 
	`OnDgE
(
CODaObje
* 
pDaObje
, 
DWORD
 
dwKeyS
, 
CPot
 
pot
);

398 
DROPEFFECT
 
	`OnDgOv
(
CODaObje
* 
pDaObje
, 
DWORD
 
dwKeyS
, 
CPot
 
pot
);

399 
	`OnDgLve
();

400 
BOOL
 
	`OnDr
(
CODaObje
* 
pDaObje
, 
DROPEFFECT
 
drEf
, 
CPot
 
pot
);

403 #ide
GRIDCONTROL_NO_CLIPBOARD


404 
vtu
 
	`OnEdCut
();

405 
vtu
 
	`OnEdCy
();

406 
vtu
 
	`OnEdPae
();

408 
vtu
 
	`OnEdSeA
();

410 
CClID
 
	$GNextIm
(
CClID
& 

, 
nFgs
) const;

412 
BOOL
 
	`StTextIms
(
nC
, BOOL 
bAsndg
);

413 
BOOL
 
	`StIms
(
PFNLVCOMPARE
 
pCom
, 
nC
, BOOL 
bAsndg
, 
LPARAM
 
da
 = 0);

418 
eed
:

419 
vtu
 
	`PSubassWdow
();

421 #i!
	`defed
(
_WIN32_WCE_NO_PRINTING
&& !
	$defed
(
GRIDCONTROL_NO_PRINTING
)

422 
public
:

423 
vtu
 
	`OnBegPrtg
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

424 
vtu
 
	`OnPrt
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

425 
vtu
 
	`OnEndPrtg
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

429 
public
:

430 
vtu
 ~
	`CGridCl
();

432 
eed
:

433 
BOOL
 
	`RegiWdowCss
();

434 
LRESULT
 
	`SdMesgeToPt
(
nRow
, 
nC
, 
nMesge
);

436 
BOOL
 
	`InvideClRe
(cڡ 
CClID
& 

);

437 
BOOL
 
	`InvideClRe
(cڡ 
CClRge
& 
Rge
);

438 
	`EBkgnd
(
CDC
* 
pDC
);

440 
BOOL
 
	$GClRgeRe
(cڡ 
CClRge
& 
Rge
, 
LPRECT
 
Re
) const;

442 
CGridCl
* 
	$GCl
(
nRow
, 
nC
) const;

443 
BOOL
 
	`SCl
(
nRow
, 
nC
, 
CGridCl
* 
pCl
);

445 
	$SMouMode
(
nMode
{ 
nOldMode
 = 
m_MouMode
; m_MouModnMode; OldMode; 
	}
}

446 
	$GMouMode
(cڡ {  
m_MouMode
; 
	}
}

448 
BOOL
 
	$MouOvRowResizeAa
(
CPot
& 
pot
) const;

449 
BOOL
 
	$MouOvCumnResizeAa
(
CPot
& 
pot
) const;

451 
CClID
 
	$GClFromPt
(
CPot
 
pot
, 
BOOL
 
bAowFixedClCheck
 = 
TRUE
) const;

452 
CClID
 
	$GTNFixedCl
() const;

453 
CClRge
 
	$GUnobruedNFixedClRge
() const;

454 
CClRge
 
	$GVisibNFixedClRge
(
LPRECT
 
pRe
 = 
NULL
) const;

456 
CClID
 
	`SFocusCl
(CClID 

);

457 
CClID
 
	`SFocusCl
(
nRow
, 
nC
);

459 
	`RetSeedRge
();

460 
	`RetSlBs
();

461 
	`GSlPos32
(
nB
, 
BOOL
 
bGTckPos
 = 
FALSE
);

462 
BOOL
 
	`SSlPos32
(
nB
, 
nPos
, BOOL 
bRedw
 = 
TRUE
);

464 
BOOL
 
	`StTextIms
(
nC
, BOOL 
bAsndg
, 
low
, 
high
);

465 
BOOL
 
	`StIms
(
PFNLVCOMPARE
 
pCom
, 
nC
, BOOL 
bAsndg
, 
LPARAM
 
da
,

466 
low
, 
high
);

469 
eed
:

471 #i!
	`defed
(
_WIN32_WCE_NO_PRINTING
&& !
	$defed
(
GRIDCONTROL_NO_PRINTING
)

472 
vtu
 
	`PrtCumnHdgs
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

473 
vtu
 
	`PrtHd
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

474 
vtu
 
	`PrtFoٔ
(
CDC
 *
pDC
, 
CPrtInfo
 *
pInfo
);

477 #ide
GRIDCONTROL_NO_DRAGDROP


479 
vtu
 
CImageLi
* 
	`CeDgImage
(
CPot
 *
pHSp
);

483 
vtu
 
	`OnFixedCumnClick
(
CClID
& 

);

484 
vtu
 
	`OnFixedRowClick
(
CClID
& 

);

487 
vtu
 
CSize
 
	`GClEx
(
nRow
, 
nC
, 
CDC
* 
pDC
);

488 
vtu
 
	`OnEndEdCl
(
nRow
, 
nC
, 
CSg
 
r
);

489 
vtu
 
	`OnEdCl
(
nRow
, 
nC
, 
UINT
 
nCh
);

490 
vtu
 
	`CeInPEdCڌ
(
CRe
& 

, 
DWORD
 
dwSty
, 
UINT
 
nID
,

491 
nRow
, 
nC
,

492 
LPCTSTR
 
szText
, 
nCh
);

495 
vtu
 
	`OnDw
(
CDC
* 
pDC
);

496 
vtu
 
BOOL
 
	`DwFixedCl
(
CDC
* 
pDC
, 
nRow
, 
nC
, 
CRe
 

, BOOL 
bEBk
=
FALSE
);

497 
vtu
 
BOOL
 
	`DwCl
(
CDC
* 
pDC
, 
nRow
, 
nC
, 
CRe
 

, BOOL 
bEBk
=
FALSE
);

500 
vtu
 
CGridCl
* 
	`CeCl
(
nRow
, 
nC
);

501 
vtu
 
	`EmyCl
(
CGridCl
* 
pCl
, 
nRow
, 
nC
);

504 
eed
:

506 
COLORREF
 
m_TextCour
, 
m_TextBkCour
, 
m_BkCour
,

507 
m_FixedTextCour
, 
m_FixedBkCour
, 
m_GridCour
;

508 
COLORREF
 
m_WdowText
, 
m_WdowCour
, 
m_3DFa
,

509 
m_Shadow
;

511 
m_nGridLes
;

512 
BOOL
 
m_bEdab
;

513 
BOOL
 
m_bModifd
;

514 
BOOL
 
m_bAowDgAndDr
;

515 
BOOL
 
m_bLiMode
;

516 
BOOL
 
m_bSgRowSei
;

517 
BOOL
 
m_bAowDw
;

518 
BOOL
 
m_bEbSei
;

519 
BOOL
 
m_bStOnClick
;

520 
BOOL
 
m_bHdTabKey
;

521 
BOOL
 
m_bDoubBufr
;

522 
BOOL
 
m_bTTs
;

525 
m_nRows
, 
m_nFixedRows
, 
m_nCs
, 
m_nFixedCs
;

526 
CUIAay
 
m_RowHeights
, 
m_CWidths
;

527 
m_nMg
;

528 
m_nDefClWidth
, 
m_nDefClHeight
;

529 
m_nVSlMax
, 
m_nHSlMax
;

532 
LOGFONT
 
m_Logft
;

533 
CFt
 
m_PrrFt
,

534 
m_Ft
;

535 
CImageLi
* 
m_pImageLi
;

538 
CTydPAay
<
CObAay
, 
GRID_ROW
*> 
m_RowDa
;

541 
m_MouMode
;

542 
CPot
 
m_LeClickDownPot
, 
m_LaMouPot
;

543 
CClID
 
m_LeClickDownCl
, 
m_SeiSCl
;

544 
CClID
 
m_idCutCl
;

545 
m_nTimID
;

546 
m_nTimIv
;

547 
m_nResizeCtuRge
;

548 
BOOL
 
m_bAowRowResize
, 
m_bAowCumnResize
;

549 
m_nRowsPWhlNch
;

550 
CM
<
DWORD
,DWORD, 
CClID
, CClID&> 
m_SeedClM
, 
m_PvSeedClM
;

552 #ide
GRIDCONTROL_NO_TITLETIPS


553 
CTT
 
m_TT
;

557 
BOOL
 
m_bMuUnOLE
;

558 
CClID
 
m_LaDgOvCl
;

559 #ide
GRIDCONTROL_NO_DRAGDROP


560 
CGridDrTg
 
m_DrTg
;

564 
CSize
 
m_ChSize
;

565 
m_nPageHeight
;

566 
CSize
 
m_LogilPageSize
,

567 
m_PSize
;

570 
m_bAsndg
;

571 
m_StCumn
;

573 
eed
:

574 
	`SeACls
();

575 
	`SeCumns
(
CClID
 
cutCl
);

576 
	`SeRows
(
CClID
 
cutCl
);

577 
	`SeCls
(
CClID
 
cutCl
);

578 
	`OnSeg
(cڡ 
CClID
& 
cutCl
);

582 
afx_msg
 
	`OnPat
();

583 
afx_msg
 
	`OnHSl
(
UINT
 
nSBCode
, UINT 
nPos
, 
CSlB
* 
pSlB
);

584 
afx_msg
 
	`OnVSl
(
UINT
 
nSBCode
, UINT 
nPos
, 
CSlB
* 
pSlB
);

585 
afx_msg
 
	`OnSize
(
UINT
 
nTy
, 
cx
, 
cy
);

586 
afx_msg
 
	`OnLBuUp
(
UINT
 
nFgs
, 
CPot
 
pot
);

587 
afx_msg
 
	`OnLBuDown
(
UINT
 
nFgs
, 
CPot
 
pot
);

588 
afx_msg
 
	`OnMouMove
(
UINT
 
nFgs
, 
CPot
 
pot
);

589 
afx_msg
 
	`OnTim
(
UINT
 
nIDEvt
);

590 
afx_msg
 
UINT
 
	`OnGDlgCode
();

591 
afx_msg
 
	`OnKeyDown
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

592 
afx_msg
 
	`OnCh
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

593 
afx_msg
 
	`OnLBuDblClk
(
UINT
 
nFgs
, 
CPot
 
pot
);

594 
afx_msg
 
BOOL
 
	`OnEBkgnd
(
CDC
* 
pDC
);

595 
afx_msg
 
BOOL
 
	`OnSCurs
(
CWnd
* 
pWnd
, 
UINT
 
nHTe
, UINT 
mesge
);

596 
afx_msg
 
	`OnSysCChge
();

597 
afx_msg
 
	`OnCtuChged
(
CWnd
 *
pWnd
);

598 
afx_msg
 
	`OnUpdeEdCy
(
CCmdUI
* 
pCmdUI
);

599 
afx_msg
 
	`OnUpdeEdCut
(
CCmdUI
* 
pCmdUI
);

600 
afx_msg
 
	`OnUpdeEdPae
(
CCmdUI
* 
pCmdUI
);

601 
afx_msg
 
	`OnUpdeEdSeA
(
CCmdUI
* 
pCmdUI
);

603 #i(
_MFC_VER
 >0x0421|| (
_WIN32_WCE
 >= 210)

604 
afx_msg
 
	`OnStgChge
(
UINT
 
uFgs
, 
LPCTSTR
 
szSei
);

606 #i!
	`defed
(
_WIN32_WCE
&& (
_MFC_VER
 >= 0x0421)

607 
afx_msg
 
BOOL
 
	`OnMouWhl
(
UINT
 
nFgs
, 
zD
, 
CPot
 

);

609 
afx_msg
 
LRESULT
 
	`OnSFt
(
WPARAM
 
hFt
, 
LPARAM
 
lPam
);

610 
afx_msg
 
LRESULT
 
	`OnGFt
(
WPARAM
 
hFt
, 
LPARAM
 
lPam
);

611 
afx_msg
 
	`OnEndInPEd
(
NMHDR
* 
pNMHDR
, 
LRESULT
* 
pResu
);

612 
	$DECLARE_MESSAGE_MAP
()

614 
	eeMouModes
 { 
MOUSE_NOTHING
, 
MOUSE_SELECT_ALL
, 
MOUSE_SELECT_COL
, 
MOUSE_SELECT_ROW
,

615 
MOUSE_SELECT_CELLS
, 
MOUSE_SCROLLING_CELLS
,

616 
MOUSE_OVER_ROW_DIVIDE
, 
MOUSE_SIZING_ROW
,

617 
MOUSE_OVER_COL_DIVIDE
, 
MOUSE_SIZING_COL
,

618 
MOUSE_PREPARE_EDIT
,

619 #ide
GRIDCONTROL_NO_DRAGDROP


620 
MOUSE_PREPARE_DRAG
, 
MOUSE_DRAGGING


622 
	}
};

625 
le
 
CGridCl
* 
	gCGridCl
::
	$GCl
(
nRow
, 
nC
) const

627 i(
nRow
 < 0 ||Row >
m_nRows
 || 
nC
 < 0 ||C >
m_nCs
 
NULL
;

629 
GRID_ROW
* 
pRow
 = 
m_RowDa
[
nRow
];

630 i(!
pRow
 
NULL
;

631  
pRow
->
	`GAt
(
nC
);

632 
	}
}

634 
le
 
BOOL
 
	gCGridCl
::
	$SCl
(
nRow
, 
nC
, 
CGridCl
* 
pCl
)

636 i(
nRow
 < 0 ||Row >
m_nRows
 || 
nC
 < 0 ||C >
m_nCs
 
FALSE
;

638 
GRID_ROW
* 
pRow
 = 
m_RowDa
[
nRow
];

639 i(!
pRow
 
FALSE
;

641 
pRow
->
	`SAt
(
nC
, 
pCl
);

642  
TRUE
;

643 
	}
}

	@gridctrl_src/GridDropTarget.h

1 #i!
defed
(
AFX_GRIDDROPTARGET_H__5C610981_BD36_11D1_97CD_00A0243D1382__INCLUDED_
)

2 
	#AFX_GRIDDROPTARGET_H__5C610981_BD36_11D1_97CD_00A0243D1382__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



15 
	~<afxe.h
>

17 
ass
 
	gCGridCl
;

22 as
	cCGridDrTg
 : 
public
 
CODrTg


24 
public
:

25 
CGridDrTg
();

26 
	mvtu
 ~
CGridDrTg
();

29 
	mpublic
:

30 
CGridCl
* 
m_pGridCl
;

31 
BOOL
 
	mm_bRegied
;

34 
	mpublic
:

35 
BOOL
 
Regi
(
CGridCl
 *
pGridCl
);

36 
vtu
 
Revoke
();

38 
BOOL
 
OnDr
(
CWnd
* 
pWnd
, 
CODaObje
* 
pDaObje
, 
DROPEFFECT
 
drEf
, 
CPot
 
pot
);

39 
DROPEFFECT
 
OnDgE
(
CWnd
* 
pWnd
, 
CODaObje
* 
pDaObje
, 
DWORD
 
dwKeyS
, 
CPot
 
pot
);

40 
OnDgLve
(
CWnd
* 
pWnd
);

41 
DROPEFFECT
 
OnDgOv
(
CWnd
* 
pWnd
, 
CODaObje
* 
pDaObje
, 
DWORD
 
dwKeyS
, 
CPot
 
pot
);

42 
DROPEFFECT
 
OnDgSl
(
CWnd
* 
pWnd
, 
DWORD
 
dwKeyS
, 
CPot
 
pot
);

50 
	meed
:

56 
DECLARE_MESSAGE_MAP
()

	@gridctrl_src/InPlaceEdit.h

1 #i!
defed
(
AFX_INPLACEEDIT_H__ECD42821_16DF_11D1_992F_895E185F9C72__INCLUDED_
)

2 
	#AFX_INPLACEEDIT_H__ECD42821_16DF_11D1_992F_895E185F9C72__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



40 as
	cCInPEd
 : 
public
 
CEd


43 
public
:

44 
CInPEd
(
CWnd
* 
pPt
, 
CRe
& 

, 
DWORD
 
dwSty
, 
UINT
 
nID
,

45 
nRow
, 
nCumn
, 
CSg
 
sInText
, 
UINT
 
nFCh
);

48 
	mpublic
:

51 
public
:

52 
EndEd
();

57 
	mpublic
:

58 
vtu
 
BOOL
 
PTneMesge
(
MSG
* 
pMsg
);

59 
	meed
:

60 
vtu
 
PoNcDeroy
();

64 
	mpublic
:

65 
vtu
 ~
CInPEd
();

68 
	meed
:

70 
afx_msg
 
OnKlFocus
(
CWnd
* 
pNewWnd
);

71 
afx_msg
 
OnCh
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

72 
afx_msg
 
OnKeyDown
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

73 
afx_msg
 
UINT
 
OnGDlgCode
();

75 
	$DECLARE_MESSAGE_MAP
()

77 
ive
:

78 
m_nRow
;

79 
m_nCumn
;

80 
CSg
 
m_sInText
;

81 
UINT
 
m_nLaCh
;

82 
BOOL
 
m_bExOnAows
;

83 
CRe
 
m_Re
;

	@gridctrl_src/InPlaceList.h

1 #i!
defed
(
AFX_INPLACELIST_H__ECD42822_16DF_11D1_992F_895E185F9C72__INCLUDED_
)

2 
	#AFX_INPLACELIST_H__ECD42822_16DF_11D1_992F_895E185F9C72__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



37 
	#IDC_COMBOEDIT
 1001

	)

42 as
	cCComboEd
 : 
public
 
CEd


45 
public
:

46 
CComboEd
();

49 
	mpublic
:

52 
public
:

57 
vtu
 
BOOL
 
PTneMesge
(
MSG
* 
pMsg
);

61 
	mpublic
:

62 
vtu
 ~
CComboEd
();

65 
	meed
:

67 
afx_msg
 
OnKlFocus
(
CWnd
* 
pNewWnd
);

68 
afx_msg
 
OnKeyDown
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

69 
afx_msg
 
OnKeyUp
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

72 
DECLARE_MESSAGE_MAP
()

78 as
	cCInPLi
 : 
public
 
CComboBox


80 
nd
 
ass
 
CComboEd
;

83 
	mpublic
:

84 
CInPLi
(
CWnd
* 
pPt
,

85 
CRe
& 

,

86 
DWORD
 
dwSty
,

87 
UINT
 
nID
,

88 
nRow
, 
nCumn
,

89 
CSgAay
& 
Ims
,

90 
CSg
 
sInText
,

91 
UINT
 
nFCh
);

94 
	mpublic
:

95 
CComboEd
 
m_ed
;

98 
	mpublic
:

103 
eed
:

104 
vtu
 
PoNcDeroy
();

108 
	mpublic
:

109 
vtu
 ~
CInPLi
();

110 
	meed
:

111 
EndEd
();

114 
	meed
:

116 
afx_msg
 
OnKlFocus
(
CWnd
* 
pNewWnd
);

117 
afx_msg
 
OnKeyDown
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

118 
afx_msg
 
OnKeyUp
(
UINT
 
nCh
, UINT 
nRC
, UINT 
nFgs
);

121 
	$DECLARE_MESSAGE_MAP
()

123 
ive
:

124 
m_nNumLes
;

125 
CSg
 
m_sInText
;

126 
m_nRow
;

127 
m_nC
;

128 
UINT
 
m_nLaCh
;

129 
BOOL
 
m_bExOnAows
;

	@gridctrl_src/MemDC.h

1 #i!
defed
(
AFX_MEMDC_H__CA1D3541_7235_11D1_ABBA_00A0243D1382__INCLUDED_
)

2 
	#AFX_MEMDC_H__CA1D3541_7235_11D1_ABBA_00A0243D1382__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



26 as
	cCMemDC
 : 
public
 
CDC


28 
public
:

31 
	$CMemDC
(
CDC
* 
pDC
: 
	$CDC
()

33 
	`ASSERT
(
pDC
 !
NULL
);

35 
m_pDC
 = 
pDC
;

36 
m_pOldBm
 = 
NULL
;

37 #ide
WCE_NO_PRINTING


38 
m_bMemDC
 = !
pDC
->
	`IsPrtg
();

40 
m_bMemDC
 = 
FALSE
;

43 i(
m_bMemDC
)

45 
pDC
->
	`GClBox
(&
m_
);

46 
	`CeComtibDC
(
pDC
);

47 
m_bm
.
	`CeComtibBm
(
pDC
, 
m_
.
	`Width
(), m_.
	`Height
());

48 
m_pOldBm
 = 
	`SeObje
(&
m_bm
);

49 #ide
_WIN32_WCE


50 
	`SWdowOrg
(
m_
.

, m_.
t
);

55 #ide
WCE_NO_PRINTING


56 
m_bPrtg
 = 
pDC
->m_bPrinting;

58 
m_hDC
 = 
pDC
->m_hDC;

59 
m_hAribDC
 = 
pDC
->m_hAttribDC;

64 ~
	$CMemDC
()

66 i(
m_bMemDC
)

69 
m_pDC
->
	`BB
(
m_
.

, m_.
t
, m_.
	`Width
(), m_.
	`Height
(),

70 
this
, 
m_
.

, m_.
t
, 
SRCCOPY
);

73 
	`SeObje
(
m_pOldBm
);

78 
m_hDC
 = 
m_hAribDC
 = 
NULL
;

80 
	}
}

83 
CMemDC
* 
	gݔ
->({ 
	gthis
;}

86 
ݔ
 
	gCMemDC
*({ 
	gthis
;}

88 
	give
:

89 
CBm
 
m_bm
;

90 
CBm
* 
	gm_pOldBm
;

91 
CDC
* 
	gm_pDC
;

92 
CRe
 
	gm_
;

93 
BOOL
 
	gm_bMemDC
;

	@gridctrl_src/TitleTip.h

1 #i!
defed
(
AFX_TITLETIP_H__C7165DA1_187F_11D1_992F_895E185F9C72__INCLUDED_
)

2 
	#AFX_TITLETIP_H__C7165DA1_187F_11D1_992F_895E185F9C72__INCLUDED_


	)

4 #i
_MSC_VER
 >= 1000

5 #agm



10 
	#TITLETIP_CLASSNAME
 
	`_T
("ZTT")

	)

15 as
	cCTT
 : 
public
 
CWnd


18 
public
:

19 
CTT
();

20 
	mvtu
 ~
CTT
();

21 
vtu
 
BOOL
 
Ce

CWnd
 *
pPtWnd
);

24 
	mpublic
:

27 
public
:

28 
Show
(
CRe
 
T
, 
LPCTSTR
 
szTText
,

29 
xofft
 = 0, 
LPRECT
 
HovRe
 = 
NULL
, 
LPLOGFONT
 
LogFt
 = NULL);

30 
Hide
();

35 
	mpublic
:

36 
vtu
 
BOOL
 
PTneMesge
(
MSG
* 
pMsg
);

40 
	mpublic
:

42 
eed
:

43 
CWnd
 *
m_pPtWnd
;

44 
CRe
 
	mm_T
;

45 
CRe
 
	mm_Hov
;

48 
	meed
:

50 
afx_msg
 
OnMouMove
(
UINT
 
nFgs
, 
CPot
 
pot
);

52 
DECLARE_MESSAGE_MAP
()

	@resource.h

5 
	#IDM_ABOUTBOX
 0x0010

	)

6 
	#IDD_ABOUTBOX
 100

	)

7 
	#IDS_ABOUTBOX
 101

	)

8 
	#IDD_MAIN_DIALOG
 102

	)

9 
	#IDR_MAINFRAME
 128

	)

10 
	#IDD_SHORT_TEST_DIALOG
 129

	)

11 
	#IDD_CONFIG_DIALOG
 130

	)

12 
	#IDC_BUTTON_SHORT_TEST
 1000

	)

13 
	#IDC_BUTTON_CONFIG
 1001

	)

14 
	#IDC_EDIT_SQUARE_PIN_NUM
 1001

	)

15 
	#IDC_BUTTON_INPUT_SQUARE_PIN_NUM
 1002

	)

16 
	#IDC_EDIT_SQUARE_N
 1003

	)

17 
	#IDC_EDIT_BAD_PIN
 1004

	)

18 
	#IDC_BUTTON_ADD_BAD_PIN
 1006

	)

19 
	#IDC_LIST_BAD_PIN
 1007

	)

20 
	#IDC_BUTTON_RESET_BAD_PIN
 1008

	)

21 
	#IDC_EDIT_SQUARE_MATRIX
 1009

	)

22 
	#IDC_EDIT_MEAS_OUTPUT
 1010

	)

23 
	#IDC_BUTTON_MEASURE
 1011

	)

24 
	#IDC_CHECK1
 1012

	)

25 
	#IDC_CHECK_EXCLUDE_VC
 1013

	)

26 
	#IDC_CHECK_PRT_BASIC
 1085

	)

27 
	#IDC_CHECK_PRT_LEVEL1
 1086

	)

28 
	#IDC_CHECK_PRT_Lev2
 1087

	)

29 
	#IDC_CHECK_PRT_LEVEL3
 1088

	)

30 
	#IDC_CHECK_PRT_DEVICE
 1089

	)

31 
	#IDC_CHECK_PRT_DEV_D64
 1090

	)

32 
	#IDC_STATIC_PRINT_STATE
 1091

	)

33 
	#IDC_STATIC_USED_MEM
 1092

	)

37 #ifde
APSTUDIO_INVOKED


38 #ide
APSTUDIO_READONLY_SYMBOLS


39 
	#_APS_NEXT_RESOURCE_VALUE
 131

	)

40 
	#_APS_NEXT_COMMAND_VALUE
 32771

	)

41 
	#_APS_NEXT_CONTROL_VALUE
 1014

	)

42 
	#_APS_NEXT_SYMED_VALUE
 101

	)

	@stdafx.h

6 #i!
defed
(
AFX_STDAFX_H__162EFA7F_2283_401E_A2DD_16AA1B7EE8C3__INCLUDED_
)

7 
	#AFX_STDAFX_H__162EFA7F_2283_401E_A2DD_16AA1B7EE8C3__INCLUDED_


	)

9 #i
_MSC_VER
 > 1000

10 #agm



13 
	#VC_EXTRALEAN


14 

	)

15 
	~<afxw.h
>

16 
	~<afxext.h
>

17 
	~<afxdi.h
>

18 
	~<afxdtl.h
>

19 #ide
_AFX_NO_AFXCMN_SUPPORT


20 
	~<afxcmn.h
>

	@
1
.
0
16
293
ACE400MainDlg.h
ACE400_ShortTest.h
ConfigDialog.h
Error.h
Globals.h
ShortTestDialog.h
StdAfx.h
gridctrl_src/CellRange.h
gridctrl_src/GridCtrl.h
gridctrl_src/GridDropTarget.h
gridctrl_src/InPlaceEdit.h
gridctrl_src/InPlaceList.h
gridctrl_src/MemDC.h
gridctrl_src/TitleTip.h
resource.h
stdafx.h
